<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=GB2312">
            <title>Data Structure</title>
            <link rel="stylesheet" type="text/css" href="style.css"></link>
    </head>
    
<body>
	<a name="top">
        <span>
            <a href="#Hash">Hash</a>
            <a href="#Sorting">Sorting</a>
 			<a href="#StackQueue">Stack and Queue</a>
			<a href="#LinkedList">Linked List</a>
            <a href="#Graph">Graph</a>
            
        </span>
        <span><a class="link" href="./index.html" >Homepage </a></span>

    <a name="Hash">
            <div class="para">
            <strong class="head">Hash:</a></strong><br>
           The hashing of a key to an already-filled array cell is "Collision".<br>
		   Collisions can be handled in two major ways: <strong>open addressing</strong> and <strong>separate chaining</strong>.<br><br>
		  1.  In open addressing, data items that hash to a full array cell are placed in another cell in the array.<br>

            &nbsp;&nbsp;&nbsp;1) <strong>linear probing:</strong> x,x+1,x+2,x+3...x is the array index after hash function. contiguous sequences of filled cells appear, which is called primary clusters.<br>
			&nbsp;&nbsp;&nbsp;2) <strong>quadratic probing:</strong> x,x+1,x+4,x+9,x+16...still have Secondary cluster<br>
			&nbsp;&nbsp;&nbsp;3) <strong>double hashing:</strong> x, x+s, x+2s, x+3s, x+4s... s is the step size depends on the key and is obtained from a secondary hash function.<br>
		2. In separate chaining, each array element consists of a linked list. All data items hashing to a given array index are inserted in that list.<br>			
            <br>
             * HashMap is implemented as a hash table, and there is no ordering on keys or values. Dog has to override hashcode and equals method<br>
	 * TreeMap is implemented based on red-black tree structure, and it is ordered by the key.   Dog has to implement Comparable interface, TreeMap now uses compareTo() method to compare keys. if two dogs compareTo = 0, only save one dog<br>
	 * LinkedHashMap preserves the insertion order<br>
	 * Hashtable is synchronized, in contrast to HashMap.<br>
            </div>
        
    
	<a name="StackQueue">
		<div class="para">
		     <strong class="head">Stack and Queue:</a></strong><br> 
			<object data="./other/Stack and Queue.txt" type="text/plain" width="100%" style="height:37em">
			<a href="./other/Stack and Queue.txt">Embedded Text Document</a>
			</object>	
		</div> 
		
	<a name="LinkedList">
		<div class="para">
			<strong class="head">Linked List:</a></strong><br> 
			<object data="./other/Linked List.txt" type="text/plain" width="100%" style="height:17em">
			<a href="./other/Linked List.txt">Embedded Text Document</a>
			</object>	
		</div>
		
		      
  		<a name="Sorting">
			<div class="para">
				<strong class="head">Sort and Search:</a></strong><br> 
				<object data="./other/Sort.txt" type="text/plain" width="100%" style="height:37em">
				<a href="./other/Sort.txt">Embedded Text Document</a>
				</object>	
			</div>
            
    <a name="Graph">
        <div class="para">
                <strong class="head">Graph BFS, DFS</a></strong><br>
          The BFS begins at a root node and inspects all the neighboring nodes. Then for each of those neighbor nodes in turn, it inspects their neighbor nodes which were unvisited, and so on.  <strong>Queue</strong><br>
          
          DFS starts at the root and explores as far as possible along each branch before backtracking. <strong>Recursive or Stack</strong><br>
          Pre-order tree travsal is a form of DFS, key difference is that for graph, we must check if a node has been visited.<br>
           <strong class="head">Compare BFS, DFS</a></strong><br>
          DFS can be done by a simple recursion.<br>
          BFS can be used to find shortest path, whereas DFS may traverse one adjancent node very deeply before ever going onto the immediate neighbors.<br>
        </div>
    
            
	<a name="NEXT">
	<div class="para">
	<strong class="head">NEXT:</a></strong><br>
	<a href="#top">Back</a></div>
	
	
</body>
</html>